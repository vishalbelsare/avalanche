

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>avalanche.training.strategies.new_strategy_api.strategy_flow &mdash; Avalanche 0.1 documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../../../../../../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../../../../../" src="../../../../../../_static/documentation_options.js"></script>
        <script src="../../../../../../_static/jquery.js"></script>
        <script src="../../../../../../_static/underscore.js"></script>
        <script src="../../../../../../_static/doctools.js"></script>
        <script src="../../../../../../_static/language_data.js"></script>
    
    <script type="text/javascript" src="../../../../../../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../../../../../../_static/css/mystyle.css" type="text/css" />
  <link rel="stylesheet" href="../../../../../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../../../../../_static/graphviz.css" type="text/css" />
    <link rel="index" title="Index" href="../../../../../../genindex/" />
    <link rel="search" title="Search" href="../../../../../../search/" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../../../../../" class="icon icon-home"> Avalanche
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../../../../search/" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Avalanche API:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../../../autoapi/">API Reference</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../../../../autoapi/avalanche/"><code class="xref py py-mod docutils literal notranslate"><span class="pre">avalanche</span></code></a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../../../../autoapi/avalanche/#subpackages">Subpackages</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../../../../autoapi/avalanche/benchmarks/"><code class="xref py py-mod docutils literal notranslate"><span class="pre">avalanche.benchmarks</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../../../autoapi/avalanche/evaluation/"><code class="xref py py-mod docutils literal notranslate"><span class="pre">avalanche.evaluation</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../../../autoapi/avalanche/extras/"><code class="xref py py-mod docutils literal notranslate"><span class="pre">avalanche.extras</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../../../autoapi/avalanche/training/"><code class="xref py py-mod docutils literal notranslate"><span class="pre">avalanche.training</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../../../../autoapi/avalanche/#submodules">Submodules</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../../../../autoapi/avalanche/constants/"><code class="xref py py-mod docutils literal notranslate"><span class="pre">avalanche.constants</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../../../../autoapi/avalanche/#package-contents">Package Contents</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../../../../autoapi/avalanche/#avalanche.__version__">__version__</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../../../autoapi/avalanche/#avalanche.AVALANCHE_BP">AVALANCHE_BP</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../../../autoapi/avalanche/#avalanche.ARTIFACTS_BP">ARTIFACTS_BP</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../../../../">Avalanche</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../../../../../">Docs</a> &raquo;</li>
        
          <li><a href="../../../../../">Module code</a> &raquo;</li>
        
      <li>avalanche.training.strategies.new_strategy_api.strategy_flow</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for avalanche.training.strategies.new_strategy_api.strategy_flow</h1><div class="highlight"><pre>
<span></span><span class="ch">#!/usr/bin/env python</span>
<span class="c1"># -*- coding: utf-8 -*-</span>

<span class="c1">################################################################################</span>
<span class="c1"># Copyright (c) 2020 ContinualAI Research                                      #</span>
<span class="c1"># Copyrights licensed under the CC BY 4.0 License.                             #</span>
<span class="c1"># See the accompanying LICENSE file for terms.                                 #</span>
<span class="c1">#                                                                              #</span>
<span class="c1"># Date: 11-09-2020                                                             #</span>
<span class="c1"># Author(s): Lorenzo Pellegrini                                                #</span>
<span class="c1"># E-mail: contact@continualai.org                                              #</span>
<span class="c1"># Website: clair.continualai.org                                               #</span>
<span class="c1">################################################################################</span>


<span class="kn">import</span> <span class="nn">functools</span>
<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">import</span> <span class="nn">warnings</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">OrderedDict</span>
<span class="kn">from</span> <span class="nn">inspect</span> <span class="kn">import</span> <span class="n">signature</span><span class="p">,</span> <span class="n">Parameter</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Callable</span><span class="p">,</span> <span class="n">Union</span><span class="p">,</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">,</span> <span class="n">List</span><span class="p">,</span> <span class="n">Dict</span><span class="p">,</span> <span class="n">Any</span><span class="p">,</span> \
    <span class="n">Iterable</span>


<span class="k">def</span> <span class="nf">_merge_state_data</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">in_place</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Merges two &quot;dictionary&quot; objects together by updating the content of the</span>
<span class="sd">    first parameter. By default, creates a new copy of it.</span>

<span class="sd">    The first parameter must be a Python dict while the second parameter can be</span>
<span class="sd">    a dict, a named tuple or a :class:`StrategyFlow`. If the second parameter</span>
<span class="sd">    is a plain object, the ``vars()`` built-in function  will be used to obtain</span>
<span class="sd">    a dictionary out of it.</span>

<span class="sd">    :param a: The original dictionary object.</span>
<span class="sd">    :param b: The update dictionary object.</span>
<span class="sd">    :param in_place: If True, a will be updated without making a copy of it.</span>
<span class="sd">        Defaults to False.</span>
<span class="sd">    :return: A dictionary objects containing the elements from the given</span>
<span class="sd">        dictionary parameters. Keys contained in the second parameter take</span>
<span class="sd">        precedence over the ones of the first parameter.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">in_place</span><span class="p">:</span>
        <span class="n">a</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">StrategyFlow</span><span class="p">):</span>
        <span class="n">a</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">b</span><span class="o">.</span><span class="n">extract_self_namespace</span><span class="p">())</span>
        <span class="n">a</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">b</span><span class="o">.</span><span class="n">get_results_namespace</span><span class="p">())</span>
        <span class="n">a</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">b</span><span class="o">.</span><span class="n">get_flattened_kwargs</span><span class="p">())</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>  <span class="c1"># Also considers OrderedDict</span>
        <span class="n">a</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
    <span class="k">elif</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="s1">&#39;_asdict&#39;</span><span class="p">):</span>  <span class="c1"># Manages namedtuple</span>
        <span class="n">a</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">b</span><span class="o">.</span><span class="n">_asdict</span><span class="p">())</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">a</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="nb">vars</span><span class="p">(</span><span class="n">b</span><span class="p">))</span>  <span class="c1"># Treat as plain object</span>

    <span class="k">return</span> <span class="n">a</span>


<span class="k">def</span> <span class="nf">_match_positional_arguments</span><span class="p">(</span><span class="n">part</span><span class="p">:</span> <span class="n">Callable</span><span class="p">,</span> <span class="n">pos_args</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">Any</span><span class="p">]):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Given a function and the list of parameters passed to it in a positional</span>
<span class="sd">    way, separates the &quot;positional only&quot; parameters from the &quot;positional or</span>
<span class="sd">    keyword&quot; ones.</span>

<span class="sd">    :param part: The callable object.</span>
<span class="sd">    :param pos_args: The list of positional arguments.</span>
<span class="sd">    :return: A tuple containing two elements: the first element is an ordered</span>
<span class="sd">        dictionary of &quot;positional only&quot; arguments, with keys being the parameter</span>
<span class="sd">        names. The second is an ordered dictionary of &quot;positional or keyword&quot;</span>
<span class="sd">        parameters, with keys being the parameter names.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">part_signature</span> <span class="o">=</span> <span class="n">signature</span><span class="p">(</span><span class="n">part</span><span class="p">)</span>
    <span class="n">keyword_params</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span>
    <span class="n">positional_params</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span>

    <span class="c1"># From the doc of &quot;inspect.Signature.parameters&quot;:</span>
    <span class="c1"># https://docs.python.org/3/library/inspect.html</span>
    <span class="c1"># An ordered mapping of parametersâ€™ names to the corresponding Parameter</span>
    <span class="c1"># objects. Parameters appear in strict definition order, including</span>
    <span class="c1"># keyword-only parameters.</span>
    <span class="k">for</span> <span class="n">param_idx</span><span class="p">,</span> <span class="n">parameter_name</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">part_signature</span><span class="o">.</span><span class="n">parameters</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">param_idx</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">pos_args</span><span class="p">):</span>
            <span class="k">break</span>
        <span class="n">kind</span> <span class="o">=</span> <span class="n">part_signature</span><span class="o">.</span><span class="n">parameters</span><span class="p">[</span><span class="n">parameter_name</span><span class="p">]</span><span class="o">.</span><span class="n">kind</span>
        <span class="k">if</span> <span class="n">kind</span> <span class="o">==</span> <span class="n">Parameter</span><span class="o">.</span><span class="n">POSITIONAL_OR_KEYWORD</span><span class="p">:</span>
            <span class="n">keyword_params</span><span class="p">[</span><span class="n">parameter_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">pos_args</span><span class="p">[</span><span class="n">param_idx</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">kind</span> <span class="o">==</span> <span class="n">Parameter</span><span class="o">.</span><span class="n">POSITIONAL_ONLY</span><span class="p">:</span>
            <span class="n">positional_params</span><span class="p">[</span><span class="n">parameter_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">pos_args</span><span class="p">[</span><span class="n">param_idx</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">positional_params</span><span class="p">,</span> <span class="n">keyword_params</span>


<span class="n">StrategyPart</span> <span class="o">=</span> <span class="n">Callable</span>
<span class="n">StrategyChild</span> <span class="o">=</span> <span class="n">Union</span><span class="p">[</span><span class="s1">&#39;FlowGroup&#39;</span><span class="p">,</span> <span class="n">StrategyPart</span><span class="p">]</span>
<span class="n">StrategyChildId</span> <span class="o">=</span> <span class="n">Union</span><span class="p">[</span><span class="n">StrategyChild</span><span class="p">,</span> <span class="nb">str</span><span class="p">]</span>


<span class="k">def</span> <span class="nf">_is_func_decorated</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">check_flow</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Checks if the given function was decorated using a decorator returned from</span>
<span class="sd">    make_strategy_part_decorator.</span>

<span class="sd">    :param f: The function to check.</span>
<span class="sd">    :param check_flow: If not None, must be the name of a specific instance of</span>
<span class="sd">        a decorator returned from make_strategy_part_decorator.</span>
<span class="sd">    :return: True if the function is decorated. If check_flow is not None,</span>
<span class="sd">        returns True if the function is decorated and one of the decorators</span>
<span class="sd">        is the one whose name is specified by the check_flow parameter.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">result</span> <span class="o">=</span> <span class="s1">&#39;flows&#39;</span> <span class="ow">in</span> <span class="n">f</span><span class="o">.</span><span class="vm">__dict__</span>
    <span class="k">if</span> <span class="n">check_flow</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">result</span><span class="p">:</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">check_flow</span> <span class="ow">in</span> <span class="n">f</span><span class="o">.</span><span class="n">flows</span>
    <span class="k">return</span> <span class="n">result</span>


<div class="viewcode-block" id="make_strategy_part_decorator"><a class="viewcode-back" href="../../../../../../autoapi/avalanche/training/strategies/new_strategy_api/strategy_flow/#avalanche.training.strategies.new_strategy_api.make_strategy_part_decorator">[docs]</a><span class="k">def</span> <span class="nf">make_strategy_part_decorator</span><span class="p">(</span><span class="n">flow_field</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Factory for a strategy part decorator.</span>

<span class="sd">    :param flow_field: The name of the decorator.</span>
<span class="sd">    :return: A decorator that can be used to decorate class methods.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">call_strategy_part</span><span class="p">(</span><span class="n">f</span><span class="p">):</span>
        <span class="c1"># Ok, from now on don&#39;t touch anything</span>
        <span class="c1"># https://www.python.org/dev/peps/pep-0232/</span>
        <span class="n">use_existing_wrapper</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">_is_func_decorated</span><span class="p">(</span><span class="n">f</span><span class="p">):</span>
            <span class="n">f</span><span class="o">.</span><span class="n">flows</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">use_existing_wrapper</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">if</span> <span class="n">flow_field</span> <span class="ow">in</span> <span class="n">f</span><span class="o">.</span><span class="n">flows</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Error decorating &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="vm">__name__</span><span class="p">)</span> <span class="o">+</span>
                             <span class="s1">&#39;, &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">flow_field</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;flow was &#39;</span> <span class="o">+</span>
                             <span class="s1">&#39;already added to this method&#39;</span><span class="p">)</span>
        <span class="n">f</span><span class="o">.</span><span class="n">flows</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">flow_field</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">use_existing_wrapper</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">f</span><span class="o">.</span><span class="n">flow_wrapper</span>

        <span class="nd">@functools</span><span class="o">.</span><span class="n">wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
        <span class="k">def</span> <span class="nf">wrapper</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
            <span class="n">all_flows</span> <span class="o">=</span> <span class="p">[</span><span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">st_name</span><span class="p">)</span>
                         <span class="k">for</span> <span class="n">st_name</span> <span class="ow">in</span> <span class="n">f</span><span class="o">.</span><span class="n">flows</span><span class="p">]</span>
            <span class="n">flow</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">StrategyFlow</span><span class="p">]</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span>
                <span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">st</span><span class="p">:</span> <span class="n">st</span><span class="o">.</span><span class="n">is_running</span><span class="p">(),</span> <span class="n">all_flows</span><span class="p">),</span> <span class="kc">None</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">flow</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># Method is not being used by a flow, which means that it was</span>
                <span class="c1"># called directly.</span>
                <span class="k">return</span> <span class="n">f</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

            <span class="n">pos_arguments</span><span class="p">,</span> <span class="n">pos_kw_arguments</span> <span class="o">=</span> <span class="n">_match_positional_arguments</span><span class="p">(</span>
                <span class="n">f</span><span class="p">,</span> <span class="p">(</span><span class="bp">self</span><span class="p">,)</span> <span class="o">+</span> <span class="n">args</span><span class="p">)</span>

            <span class="c1"># pos_kw_arguments and kwargs may contain the same keys</span>
            <span class="c1"># (parameter names), but it will be the exact same parameter!</span>
            <span class="n">pos_kw_and_kwargs</span> <span class="o">=</span> <span class="p">{</span><span class="o">**</span><span class="n">pos_kw_arguments</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">}</span>

            <span class="c1"># Check if we have to call submodules functions</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">flow</span><span class="o">.</span><span class="n">is_submodule_flow</span><span class="p">():</span>
                <span class="n">kwargs_submodule</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">pos_kw_and_kwargs</span><span class="p">)</span>
                <span class="n">kwargs_submodule</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;self&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

                <span class="c1"># We are in the root flow. This means that the function is</span>
                <span class="c1"># being called on the main strategy object. Before calling</span>
                <span class="c1"># the actual function we have to execute the methods with</span>
                <span class="c1"># the same name found in submodules.</span>
                <span class="k">for</span> <span class="n">submodule</span> <span class="ow">in</span> <span class="n">flow</span><span class="o">.</span><span class="n">get_strategy_submodules</span><span class="p">():</span>
                    <span class="c1"># First, check if the field with the same name is</span>
                    <span class="c1"># actually a submodule&#39;s method. Any other callables</span>
                    <span class="c1"># are ok too.</span>
                    <span class="n">submodule_callback</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">submodule</span><span class="p">,</span> <span class="n">f</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">callable</span><span class="p">(</span><span class="n">submodule_callback</span><span class="p">)</span> <span class="ow">and</span> <span class="n">_is_func_decorated</span><span class="p">(</span>
                            <span class="n">submodule_callback</span><span class="p">,</span>
                            <span class="n">check_flow</span><span class="o">=</span><span class="n">flow</span><span class="o">.</span><span class="n">flow_name</span><span class="p">):</span>
                        <span class="c1"># Actually call the submodule function</span>
                        <span class="k">try</span><span class="p">:</span>
                            <span class="nb">getattr</span><span class="p">(</span><span class="n">submodule</span><span class="p">,</span> <span class="n">f</span><span class="o">.</span><span class="vm">__name__</span><span class="p">)(</span><span class="o">**</span><span class="n">kwargs_submodule</span><span class="p">)</span>
                        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">_</span><span class="p">:</span>
                            <span class="n">t</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">tb</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">exc_info</span><span class="p">()</span>
                            <span class="n">flow</span><span class="o">.</span><span class="n">signal_internal_traceback</span><span class="p">(</span><span class="n">tb</span><span class="p">)</span>
                            <span class="k">raise</span>

            <span class="c1"># pos_arguments may contain different parameters with the</span>
            <span class="c1"># same keys (names) from pos_kw_and_kwargs.</span>
            <span class="c1"># https://www.python.org/dev/peps/pep-0570/#semantic-corner-case</span>
            <span class="c1"># Not that we care... we just don&#39;t push positional-only arguments</span>
            <span class="c1"># to the kwargs stack!</span>
            <span class="c1"># Also, positional-only arguments are extremely rare ...</span>
            <span class="n">flow</span><span class="o">.</span><span class="n">push_kwargs</span><span class="p">(</span><span class="n">pos_kw_and_kwargs</span><span class="p">)</span>

            <span class="k">try</span><span class="p">:</span>
                <span class="n">namespace</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
                <span class="c1"># Python, passes &quot;self&quot; as a positional argument,</span>
                <span class="c1"># no matter if the method defines self as</span>
                <span class="c1"># POSITIONAL_ONLY or POSITIONAL_OR_KEYWORD</span>
                <span class="n">_merge_state_data</span><span class="p">(</span><span class="n">namespace</span><span class="p">,</span> <span class="n">flow</span><span class="p">,</span> <span class="n">in_place</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="n">_merge_state_data</span><span class="p">(</span><span class="n">namespace</span><span class="p">,</span> <span class="n">pos_kw_arguments</span><span class="p">,</span> <span class="n">in_place</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

                <span class="k">try</span><span class="p">:</span>
                    <span class="n">ret</span> <span class="o">=</span> <span class="n">_execute_part_call</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">pos_arguments</span><span class="p">,</span> <span class="n">namespace</span><span class="p">,</span>
                                             <span class="n">flow</span><span class="p">)</span>
                <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">_</span><span class="p">:</span>
                    <span class="n">t</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">tb</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">exc_info</span><span class="p">()</span>
                    <span class="n">flow</span><span class="o">.</span><span class="n">signal_internal_traceback</span><span class="p">(</span><span class="n">tb</span><span class="p">)</span>
                    <span class="k">raise</span>

                <span class="c1"># We have to decide if this makes sense!</span>
                <span class="c1"># flow.update_results_namespace(ret)</span>
            <span class="k">finally</span><span class="p">:</span>
                <span class="n">flow</span><span class="o">.</span><span class="n">pop_kwargs</span><span class="p">()</span>

            <span class="k">return</span> <span class="n">ret</span>

        <span class="n">f</span><span class="o">.</span><span class="n">flow_wrapper</span> <span class="o">=</span> <span class="n">wrapper</span>
        <span class="n">functools</span><span class="o">.</span><span class="n">update_wrapper</span><span class="p">(</span><span class="n">wrapper</span><span class="p">,</span> <span class="n">f</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">wrapper</span>
    <span class="k">return</span> <span class="n">call_strategy_part</span></div>


<span class="n">TrainingFlow</span> <span class="o">=</span> <span class="n">make_strategy_part_decorator</span><span class="p">(</span><span class="s1">&#39;training_flow&#39;</span><span class="p">)</span>
<span class="n">TestingFlow</span> <span class="o">=</span> <span class="n">make_strategy_part_decorator</span><span class="p">(</span><span class="s1">&#39;testing_flow&#39;</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_child_name</span><span class="p">(</span><span class="n">child</span><span class="p">:</span> <span class="n">StrategyChildId</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns the flow name of the given part. The part can be a plain python</span>
<span class="sd">    function, a FlowGroup or a string.</span>

<span class="sd">    :param child: The part to get the name of.</span>
<span class="sd">    :return: The part name.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">child</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">None</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">child</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="n">FlowGroup</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">child</span><span class="o">.</span><span class="n">group_name</span>
    <span class="k">return</span> <span class="n">child</span><span class="o">.</span><span class="vm">__name__</span>


<span class="k">def</span> <span class="nf">_all_element_names</span><span class="p">(</span><span class="n">parts</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">StrategyChild</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Gets the complete list of children names from a part list.</span>

<span class="sd">    :param parts: A list of parts.</span>
<span class="sd">    :return: The complete list of children names, including the names</span>
<span class="sd">        from the parts listed in the parameter.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">names</span> <span class="o">=</span> <span class="p">[</span><span class="n">_child_name</span><span class="p">(</span><span class="n">child</span><span class="p">)</span> <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="n">parts</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="n">parts</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="n">FlowGroup</span><span class="p">):</span>
            <span class="n">names</span> <span class="o">+=</span> <span class="n">child</span><span class="o">.</span><span class="n">child_names</span>

    <span class="k">return</span> <span class="n">names</span>


<span class="k">def</span> <span class="nf">_get_part_names</span><span class="p">(</span><span class="n">parts</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">StrategyChild</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Gets the names of the given parts.</span>

<span class="sd">    :param parts: The parts to get the name of.</span>
<span class="sd">    :return: The names of the given parts.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">_child_name</span><span class="p">(</span><span class="n">part</span><span class="p">)</span> <span class="k">for</span> <span class="n">part</span> <span class="ow">in</span> <span class="n">parts</span><span class="p">]</span>


<span class="k">def</span> <span class="nf">_find_part_group</span><span class="p">(</span><span class="n">parts</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">StrategyChild</span><span class="p">],</span> <span class="n">part_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> \
        <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">StrategyChild</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Finds the group the given part belongs to.</span>

<span class="sd">    This method searches for the required part in all the elements given by the</span>
<span class="sd">    first parameter (including their sub-trees). If the part is found in a</span>
<span class="sd">    sub-group, this method will return the index and reference of the relative</span>
<span class="sd">    element in the first parameter list.</span>

<span class="sd">    :param parts: The list of parts to search.</span>
<span class="sd">    :param part_name: The name of the part whose group has to be found.</span>
<span class="sd">    :return: The index and reference of its containing group. If the part is</span>
<span class="sd">        one of the elements of the &quot;parts&quot; parameter, its index and reference</span>
<span class="sd">        will be returned.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">for</span> <span class="n">part_idx</span><span class="p">,</span> <span class="n">part</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">parts</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">_child_name</span><span class="p">(</span><span class="n">part</span><span class="p">)</span> <span class="o">==</span> <span class="n">part_name</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">part_idx</span><span class="p">,</span> <span class="n">part</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">part</span><span class="p">,</span> <span class="n">FlowGroup</span><span class="p">)</span> <span class="ow">and</span> <span class="n">part_name</span> <span class="ow">in</span> <span class="n">part</span><span class="o">.</span><span class="n">child_names</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">part_idx</span><span class="p">,</span> <span class="n">part</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;No child part found with the given name&#39;</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_contains_duplicates</span><span class="p">(</span><span class="n">parts</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">StrategyChild</span><span class="p">]):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Checks if the given sequence contains parts with duplicate names.</span>

<span class="sd">    :param parts: The list of parts.</span>
<span class="sd">    :return: True if a duplicate is found, False otherwise.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">names</span> <span class="o">=</span> <span class="p">[</span><span class="n">_child_name</span><span class="p">(</span><span class="n">child</span><span class="p">)</span> <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="n">parts</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="n">parts</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="n">FlowGroup</span><span class="p">):</span>
            <span class="n">names</span> <span class="o">=</span> <span class="n">names</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="n">child</span><span class="o">.</span><span class="n">child_names</span><span class="p">)</span>

    <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="n">names</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">names</span><span class="p">))</span>


<span class="k">def</span> <span class="nf">_empty_listener</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
    <span class="k">pass</span>


<span class="k">def</span> <span class="nf">_execute_part_call</span><span class="p">(</span><span class="n">part</span><span class="p">,</span> <span class="n">positional_arguments</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">Any</span><span class="p">],</span>
                       <span class="n">namespace_dict</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">],</span>
                       <span class="n">strategy_flow</span><span class="p">:</span> <span class="s1">&#39;StrategyFlow&#39;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calls a strategy part given the positional arguments, the available keyword</span>
<span class="sd">    arguments (namespace).</span>

<span class="sd">    :param part: The part to be called.</span>
<span class="sd">    :param positional_arguments: The positional-only arguments.</span>
<span class="sd">    :param namespace_dict: The available namespace elements used to fill</span>
<span class="sd">        the remaining arguments.</span>
<span class="sd">    :param strategy_flow: The reference to the strategy flow.</span>
<span class="sd">    :return: The value returned from the part call.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="s1">&#39;flow_listeners&#39;</span> <span class="ow">in</span> <span class="n">namespace_dict</span><span class="p">:</span>
        <span class="n">flow_listeners</span> <span class="o">=</span> <span class="n">namespace_dict</span><span class="p">[</span><span class="s1">&#39;flow_listeners&#39;</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">flow_listeners</span> <span class="o">=</span> <span class="n">_empty_listener</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">flow_listeners</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">):</span>
        <span class="n">flow_listeners</span> <span class="o">=</span> <span class="p">[</span><span class="n">flow_listeners</span><span class="p">]</span>

    <span class="c1"># Get value of required parameters</span>
    <span class="n">selected_parameters</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
    <span class="n">part_signature</span> <span class="o">=</span> <span class="n">signature</span><span class="p">(</span><span class="n">part</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">parameter_name</span> <span class="ow">in</span> <span class="n">part_signature</span><span class="o">.</span><span class="n">parameters</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">part_signature</span><span class="o">.</span><span class="n">parameters</span><span class="p">[</span><span class="n">parameter_name</span><span class="p">]</span><span class="o">.</span><span class="n">kind</span> <span class="o">==</span> \
                <span class="n">Parameter</span><span class="o">.</span><span class="n">VAR_KEYWORD</span><span class="p">:</span>
            <span class="c1"># Function declared the **kwargs argument</span>
            <span class="c1"># This means that we pass the entire namespace!</span>
            <span class="n">selected_parameters</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">namespace_dict</span><span class="p">)</span>
            <span class="k">break</span>
        <span class="k">elif</span> <span class="n">part_signature</span><span class="o">.</span><span class="n">parameters</span><span class="p">[</span><span class="n">parameter_name</span><span class="p">]</span><span class="o">.</span><span class="n">kind</span> <span class="ow">in</span> \
                <span class="p">[</span><span class="n">Parameter</span><span class="o">.</span><span class="n">POSITIONAL_OR_KEYWORD</span><span class="p">,</span> <span class="n">Parameter</span><span class="o">.</span><span class="n">KEYWORD_ONLY</span><span class="p">]:</span>
            <span class="k">if</span> <span class="n">parameter_name</span> <span class="ow">in</span> <span class="n">namespace_dict</span><span class="p">:</span>
                <span class="n">selected_parameters</span><span class="p">[</span><span class="n">parameter_name</span><span class="p">]</span> <span class="o">=</span> \
                    <span class="n">namespace_dict</span><span class="p">[</span><span class="n">parameter_name</span><span class="p">]</span>

    <span class="c1"># TODO: better listeners system</span>
    <span class="c1"># Call listeners (before part execution)</span>
    <span class="p">[</span><span class="n">listener</span><span class="p">(</span><span class="s1">&#39;before&#39;</span><span class="p">,</span> <span class="n">_child_name</span><span class="p">(</span><span class="n">part</span><span class="p">),</span> <span class="n">selected_parameters</span><span class="p">)</span>
     <span class="k">for</span> <span class="n">listener</span> <span class="ow">in</span> <span class="n">flow_listeners</span><span class="p">]</span>

    <span class="c1"># Part execution</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">part_result</span> <span class="o">=</span> <span class="n">part</span><span class="p">(</span><span class="o">*</span><span class="n">positional_arguments</span><span class="p">,</span> <span class="o">**</span><span class="n">selected_parameters</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">_</span><span class="p">:</span>
        <span class="n">t</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">tb</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">exc_info</span><span class="p">()</span>
        <span class="n">strategy_flow</span><span class="o">.</span><span class="n">signal_internal_traceback</span><span class="p">(</span><span class="n">tb</span><span class="p">)</span>
        <span class="k">raise</span>

    <span class="c1"># Call listeners (after part execution)</span>
    <span class="p">[</span><span class="n">listener</span><span class="p">(</span><span class="s1">&#39;after&#39;</span><span class="p">,</span> <span class="n">_child_name</span><span class="p">(</span><span class="n">part</span><span class="p">),</span> <span class="n">selected_parameters</span><span class="p">)</span>
     <span class="k">for</span> <span class="n">listener</span> <span class="ow">in</span> <span class="n">flow_listeners</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">part_result</span>


<div class="viewcode-block" id="FlowGroup"><a class="viewcode-back" href="../../../../../../autoapi/avalanche/training/strategies/new_strategy_api/strategy_flow/#avalanche.training.strategies.new_strategy_api.FlowGroup">[docs]</a><span class="k">class</span> <span class="nc">FlowGroup</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This class defines a flow group.</span>

<span class="sd">    Simply put, a flow group contains a sequence of parts that are executed</span>
<span class="sd">    one after another when the group&#39;s __call__ method is invoked. A FlowGroup</span>
<span class="sd">    can be  also flagged as a loop, which means that the last element of the</span>
<span class="sd">    parts sequence controls whenever the loops would stop or continue by</span>
<span class="sd">    returning True (continue) or False (break). Parts can be class methods</span>
<span class="sd">    (usually decorated with @TrainingFlow or @TestingFlow) or another FlowGroup.</span>
<span class="sd">    This means that flow groups are organized in a tree where methods are the</span>
<span class="sd">    leaves and flow groups are intermediate nodes.</span>

<span class="sd">    In a StrategyFlow can&#39;t exist parts with duplicate names. A name of a part</span>
<span class="sd">    is the method name for class methods or the FlowGroup name for FlowGroups.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">flow</span><span class="p">:</span> <span class="s1">&#39;StrategyFlow&#39;</span><span class="p">,</span> <span class="n">elements</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">StrategyChild</span><span class="p">],</span>
                 <span class="n">group_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">is_loop</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Creates a new flow group.</span>

<span class="sd">        :param flow: The flow this group belongs to.</span>
<span class="sd">        :param elements: The initial sequence of parts. Parts can be methods</span>
<span class="sd">            or other FlowGroups. No duplicate names are allowed.</span>
<span class="sd">        :param group_name: The group name. Must be unique through the entire</span>
<span class="sd">            StrategyFlow tree.</span>
<span class="sd">        :param is_loop: If True, the __call__ will loop through the parts</span>
<span class="sd">            until the last part return False.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">flow</span><span class="p">:</span> <span class="s1">&#39;StrategyFlow&#39;</span> <span class="o">=</span> <span class="n">flow</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">children</span> <span class="o">=</span> <span class="n">elements</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">group_name</span> <span class="o">=</span> <span class="n">group_name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">is_loop</span> <span class="o">=</span> <span class="n">is_loop</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">child_names</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">direct_child_names</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_update_child_names</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">_contains_duplicates</span><span class="p">([</span><span class="bp">self</span><span class="p">]):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;The elements list contains duplicated elements&#39;</span><span class="p">)</span>
        <span class="n">FlowGroup</span><span class="o">.</span><span class="n">_set_parts_flow</span><span class="p">(</span><span class="n">flow</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">children</span><span class="p">)</span>

<div class="viewcode-block" id="FlowGroup.__call__"><a class="viewcode-back" href="../../../../../../autoapi/avalanche/training/strategies/new_strategy_api/strategy_flow/#avalanche.training.strategies.new_strategy_api.FlowGroup.__call__">[docs]</a>    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Executes the contained parts sequentially.</span>

<span class="sd">        If this group was created with the is_loop flag set as True, all parts</span>
<span class="sd">        will be executed in a loop until the last part returns False.</span>
<span class="sd">        :param args: Ignored</span>
<span class="sd">        :param kwargs: A dictionary of values to be set in the call namespace.</span>
<span class="sd">            Children parts that have any of these parameters in their method</span>
<span class="sd">            signature will get the relative value with the same name. This works</span>
<span class="sd">            very similar to a dependency injection.</span>

<span class="sd">            For instance, calling this group as &quot;group(device=&quot;cpu&quot;)&quot; will</span>
<span class="sd">            expose the &quot;device&quot; value to all children parts.</span>

<span class="sd">        :return: The return value of the last part. Please note that if this</span>
<span class="sd">            group is a loop, the return value will be True.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;Unnamed arguments will be ignored&#39;</span><span class="p">)</span>

        <span class="n">last_result</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">continue_loop</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="k">while</span> <span class="n">continue_loop</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">part</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">children</span><span class="p">:</span>
                <span class="c1"># Memory cleanup before next call</span>
                <span class="c1"># IDEs may report an unused assignment, but this is correct!</span>
                <span class="n">last_result</span> <span class="o">=</span> <span class="kc">None</span>

                <span class="c1"># Decorators already manages parameter selection and</span>
                <span class="c1"># namespace updates</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">last_result</span> <span class="o">=</span> <span class="n">part</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
                <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">_</span><span class="p">:</span>
                    <span class="n">t</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">tb</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">exc_info</span><span class="p">()</span>
                    <span class="c1"># Don&#39;t worry, the traceback will at least contain one</span>
                    <span class="c1"># trace of the previous line (the call to self.root_group of</span>
                    <span class="c1"># the StrategyFlow):</span>
                    <span class="c1"># &quot;last_result = part(*args, **kwargs)&quot;</span>
                    <span class="c1"># Also, the debugger will still correctly display the full</span>
                    <span class="c1"># stack!</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">flow</span><span class="o">.</span><span class="n">signal_internal_traceback</span><span class="p">(</span><span class="n">tb</span><span class="p">)</span>
                    <span class="k">raise</span>

            <span class="n">continue_loop</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_loop</span> <span class="ow">and</span> <span class="nb">bool</span><span class="p">(</span><span class="n">last_result</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">last_result</span></div>

<div class="viewcode-block" id="FlowGroup._append_elements"><a class="viewcode-back" href="../../../../../../autoapi/avalanche/training/strategies/new_strategy_api/strategy_flow/#avalanche.training.strategies.new_strategy_api.FlowGroup._append_elements">[docs]</a>    <span class="k">def</span> <span class="nf">_append_elements</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">to_group</span><span class="p">:</span> <span class="n">StrategyChildId</span><span class="p">,</span>
                         <span class="n">after_child</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">StrategyChildId</span><span class="p">],</span>
                         <span class="n">new_elements</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">StrategyChild</span><span class="p">],</span>
                         <span class="n">at_beginning</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
        <span class="n">to_group</span> <span class="o">=</span> <span class="n">_child_name</span><span class="p">(</span><span class="n">to_group</span><span class="p">)</span>
        <span class="n">after_child</span> <span class="o">=</span> <span class="n">_child_name</span><span class="p">(</span><span class="n">after_child</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">group_name</span> <span class="o">==</span> <span class="n">to_group</span><span class="p">:</span>
            <span class="n">FlowGroup</span><span class="o">.</span><span class="n">_check_compatibility</span><span class="p">(</span><span class="n">new_elements</span><span class="p">,</span> <span class="p">[</span><span class="bp">self</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">at_beginning</span><span class="p">:</span>
                <span class="n">after_child_idx</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">elif</span> <span class="n">after_child</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">after_child</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">direct_child_names</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Bad parameter after_child: can</span><span class="se">\&#39;</span><span class="s1">t &#39;</span>
                                     <span class="s1">&#39;find a child with the given name&#39;</span><span class="p">)</span>
                <span class="n">after_child_idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">direct_child_names</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">after_child</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">after_child_idx</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">direct_child_names</span><span class="p">)</span>

            <span class="n">FlowGroup</span><span class="o">.</span><span class="n">_set_parts_flow</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">flow</span><span class="p">,</span> <span class="n">new_elements</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">children</span><span class="p">[</span><span class="n">after_child_idx</span><span class="p">:</span><span class="n">after_child_idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_elements</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">child_idx</span><span class="p">,</span> <span class="n">child</span> <span class="o">=</span> <span class="n">_find_part_group</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">children</span><span class="p">,</span> <span class="n">to_group</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="n">FlowGroup</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Can only append to groups&#39;</span><span class="p">)</span>
            <span class="n">child</span><span class="o">.</span><span class="n">_append_elements</span><span class="p">(</span><span class="n">to_group</span><span class="p">,</span> <span class="n">after_child</span><span class="p">,</span> <span class="n">new_elements</span><span class="p">,</span>
                                   <span class="n">at_beginning</span><span class="o">=</span><span class="n">at_beginning</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_update_child_names</span><span class="p">()</span></div>

<div class="viewcode-block" id="FlowGroup._replace"><a class="viewcode-back" href="../../../../../../autoapi/avalanche/training/strategies/new_strategy_api/strategy_flow/#avalanche.training.strategies.new_strategy_api.FlowGroup._replace">[docs]</a>    <span class="k">def</span> <span class="nf">_replace</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">to_be_replaced</span><span class="p">:</span> <span class="n">StrategyChildId</span><span class="p">,</span>
                 <span class="n">new_element</span><span class="p">:</span> <span class="n">StrategyChild</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">StrategyChild</span><span class="p">:</span>
        <span class="n">to_be_replaced</span> <span class="o">=</span> <span class="n">_child_name</span><span class="p">(</span><span class="n">to_be_replaced</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">to_be_replaced</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">direct_child_names</span><span class="p">:</span>
            <span class="n">child_at</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">direct_child_names</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">to_be_replaced</span><span class="p">)</span>
            <span class="n">children_without_element</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">children</span><span class="p">)</span>
            <span class="k">del</span> <span class="n">children_without_element</span><span class="p">[</span><span class="n">child_at</span><span class="p">]</span>
            <span class="n">FlowGroup</span><span class="o">.</span><span class="n">_check_compatibility</span><span class="p">(</span>
                <span class="p">[</span><span class="n">new_element</span><span class="p">],</span> <span class="n">children_without_element</span><span class="p">)</span>
            <span class="n">replaced_element</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">children</span><span class="p">[</span><span class="n">child_at</span><span class="p">]</span>
            <span class="n">FlowGroup</span><span class="o">.</span><span class="n">_set_parts_flow</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">flow</span><span class="p">,</span>
                                      <span class="p">[</span><span class="n">new_element</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">children</span><span class="p">[</span><span class="n">child_at</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_element</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">child_idx</span><span class="p">,</span> <span class="n">child</span> <span class="o">=</span> <span class="n">_find_part_group</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">children</span><span class="p">,</span> <span class="n">to_be_replaced</span><span class="p">)</span>
            <span class="c1"># Note: can&#39;t be a Callable as they are leaves</span>
            <span class="n">replaced_element</span> <span class="o">=</span> <span class="n">child</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">to_be_replaced</span><span class="p">,</span> <span class="n">new_element</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_update_child_names</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">replaced_element</span></div>

<div class="viewcode-block" id="FlowGroup._remove"><a class="viewcode-back" href="../../../../../../autoapi/avalanche/training/strategies/new_strategy_api/strategy_flow/#avalanche.training.strategies.new_strategy_api.FlowGroup._remove">[docs]</a>    <span class="k">def</span> <span class="nf">_remove</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">to_be_removed</span><span class="p">:</span> <span class="n">StrategyChildId</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">StrategyChild</span><span class="p">:</span>
        <span class="n">to_be_removed</span> <span class="o">=</span> <span class="n">_child_name</span><span class="p">(</span><span class="n">to_be_removed</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">to_be_removed</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">direct_child_names</span><span class="p">:</span>
            <span class="n">child_at</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">direct_child_names</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">to_be_removed</span><span class="p">)</span>
            <span class="n">removed_element</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">children</span><span class="p">[</span><span class="n">child_at</span><span class="p">]</span>
            <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">children</span><span class="p">[</span><span class="n">child_at</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">_</span><span class="p">,</span> <span class="n">child</span> <span class="o">=</span> <span class="n">_find_part_group</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">children</span><span class="p">,</span> <span class="n">to_be_removed</span><span class="p">)</span>
            <span class="c1"># Note: can&#39;t be a Callable as they are leaves</span>
            <span class="n">removed_element</span> <span class="o">=</span> <span class="n">child</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">to_be_removed</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_update_child_names</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">removed_element</span></div>

<div class="viewcode-block" id="FlowGroup._update_child_names"><a class="viewcode-back" href="../../../../../../autoapi/avalanche/training/strategies/new_strategy_api/strategy_flow/#avalanche.training.strategies.new_strategy_api.FlowGroup._update_child_names">[docs]</a>    <span class="k">def</span> <span class="nf">_update_child_names</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">child_names</span> <span class="o">=</span> <span class="n">_all_element_names</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">children</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">direct_child_names</span> <span class="o">=</span> <span class="n">_get_part_names</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">children</span><span class="p">)</span></div>

<div class="viewcode-block" id="FlowGroup._check_compatibility"><a class="viewcode-back" href="../../../../../../autoapi/avalanche/training/strategies/new_strategy_api/strategy_flow/#avalanche.training.strategies.new_strategy_api.FlowGroup._check_compatibility">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_check_compatibility</span><span class="p">(</span><span class="n">added_elements</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">StrategyChild</span><span class="p">],</span>
                             <span class="n">existing_elements</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">StrategyChild</span><span class="p">]):</span>
        <span class="k">if</span> <span class="n">_contains_duplicates</span><span class="p">(</span><span class="n">added_elements</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;New elements contain duplicates&#39;</span><span class="p">)</span>

        <span class="n">new_names</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">_all_element_names</span><span class="p">(</span><span class="n">added_elements</span><span class="p">))</span>
        <span class="n">existing_names</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">_all_element_names</span><span class="p">(</span><span class="n">existing_elements</span><span class="p">))</span>
        <span class="n">names_intersection</span> <span class="o">=</span> <span class="n">existing_names</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">new_names</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">names_intersection</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Element(s) with the same name of one or more of &#39;</span>
                             <span class="s1">&#39;the new elements already exist&#39;</span><span class="p">)</span></div>

<div class="viewcode-block" id="FlowGroup._change_part_flow"><a class="viewcode-back" href="../../../../../../autoapi/avalanche/training/strategies/new_strategy_api/strategy_flow/#avalanche.training.strategies.new_strategy_api.FlowGroup._change_part_flow">[docs]</a>    <span class="k">def</span> <span class="nf">_change_part_flow</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">flow</span><span class="p">:</span> <span class="s1">&#39;StrategyFlow&#39;</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_set_parts_flow</span><span class="p">(</span><span class="n">flow</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">children</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">flow</span> <span class="o">=</span> <span class="n">flow</span></div>

<div class="viewcode-block" id="FlowGroup._set_parts_flow"><a class="viewcode-back" href="../../../../../../autoapi/avalanche/training/strategies/new_strategy_api/strategy_flow/#avalanche.training.strategies.new_strategy_api.FlowGroup._set_parts_flow">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_set_parts_flow</span><span class="p">(</span><span class="n">flow</span><span class="p">:</span> <span class="s1">&#39;StrategyFlow&#39;</span><span class="p">,</span>
                        <span class="n">parts</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">StrategyChild</span><span class="p">]):</span>
        <span class="k">for</span> <span class="n">part</span> <span class="ow">in</span> <span class="n">parts</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">part</span><span class="p">,</span> <span class="n">FlowGroup</span><span class="p">):</span>
                <span class="n">part</span><span class="o">.</span><span class="n">_change_part_flow</span><span class="p">(</span><span class="n">flow</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>  <span class="c1"># Is a class method (Callable)</span>
                <span class="c1"># noinspection PyTypeChecker</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">_is_func_decorated</span><span class="p">(</span><span class="n">part</span><span class="p">,</span> <span class="n">check_flow</span><span class="o">=</span><span class="n">flow</span><span class="o">.</span><span class="n">flow_name</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                        <span class="s1">&#39;Error defining group, &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">part</span><span class="o">.</span><span class="vm">__name__</span><span class="p">)</span> <span class="o">+</span>
                        <span class="s1">&#39; was not meant to be used by the &#39;</span> <span class="o">+</span>
                        <span class="nb">str</span><span class="p">(</span><span class="n">flow</span><span class="o">.</span><span class="n">flow_name</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;. Did you forget to decorate &#39;</span> <span class="o">+</span>
                        <span class="s1">&#39;the method?&#39;</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="StrategyFlow"><a class="viewcode-back" href="../../../../../../autoapi/avalanche/training/strategies/new_strategy_api/strategy_flow/#avalanche.training.strategies.new_strategy_api.StrategyFlow">[docs]</a><span class="k">class</span> <span class="nc">StrategyFlow</span><span class="p">:</span>
    <span class="c1"># TODO: manage warning (use of protected methods of FlowGroup)</span>
    <span class="c1"># TODO: better group creation and composition syntax</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Implementation of a strategy flow.</span>

<span class="sd">    A strategy flow describes the parts of a Continual Learning strategy.</span>
<span class="sd">    A parts is usually implemented as a class method of a strategy class.</span>
<span class="sd">    Parts can be joined in named groups, which makes it easier to define the</span>
<span class="sd">    flow and compose parts in higher-level nodes. Also, groups can be used to</span>
<span class="sd">    create loops (usually used to describe epochs or testing steps).</span>

<span class="sd">    Considering that parts are strategy class methods, parts are commonly used</span>
<span class="sd">    as callback mechanism (for instance &quot;before_training&quot;,</span>
<span class="sd">    &quot;after_training_epoch&quot;, etc.).</span>

<span class="sd">    Parts and groups can&#39;t be duplicated inside a flow.</span>

<span class="sd">    The two default flows are the training and testing flows, which are found</span>
<span class="sd">    in every strategy. Methods belonging to the training flow must be</span>
<span class="sd">    annotated using the @TrainingFlow decorator while methods belonging to the</span>
<span class="sd">    testing flow must be annotated with the @TestingFlow decorator. A method</span>
<span class="sd">    can be annotated with more than a flow decorator at the same time.</span>

<span class="sd">    Each strategy can also define submodules. Submodules are commonly used to</span>
<span class="sd">    modularize common reusable Continual Learning patterns such as multi-head</span>
<span class="sd">    management, rehearsal (a.k.a. replay), distillation, ... or even to attach</span>
<span class="sd">    the desired metrics system (accuracy, time, ram usage, confusion matrices,</span>
<span class="sd">    ...).</span>

<span class="sd">    The StrategyFlow is a callable object that, when executed, runs the</span>
<span class="sd">    described parts sequentially. Each call to the training flow executes an</span>
<span class="sd">    incremental training step on a &quot;batch&quot; (or &quot;task&quot;) of new data while the</span>
<span class="sd">    testing flow will run an evaluation loop on the test sets. A strategy should</span>
<span class="sd">    implement the desired training and testing procedures as parts.</span>

<span class="sd">    Each part, being a class method, can define method parameters as usual.</span>
<span class="sd">    The flow will inject the correct parameter values by looking at different</span>
<span class="sd">    locations:</span>
<span class="sd">        - first, a parameter with the same name is searched in the arguments</span>
<span class="sd">        passed to the flow. Considering that a strategy part can call other</span>
<span class="sd">        parts (to provide a callback or to obtain results), parameters passed to</span>
<span class="sd">        previous method calls in the stack are searched for, too. The collection</span>
<span class="sd">        of those values is called &quot;arguments namespace&quot;;</span>
<span class="sd">        - second, a global flow namespace exists where each part may publish its</span>
<span class="sd">        results. These values are stored and used for parameter injection and,</span>
<span class="sd">        like the arguments passed to the flow, they are discarded after each</span>
<span class="sd">        flow execution. Those values form the &quot;results namespace&quot;. The good part</span>
<span class="sd">        of it is that this namespace is shared with submodules, which makes it</span>
<span class="sd">        easier to modularize some common behaviours. When a part publishes a</span>
<span class="sd">        result, values with the same name found in the first group are</span>
<span class="sd">        discarded;</span>
<span class="sd">        - third, fields of the strategy class or any of its attached submodules</span>
<span class="sd">        are searched for. This is called &quot;self namespace&quot;. It goes without</span>
<span class="sd">        saying, those are the only namespace values that are persisted across</span>
<span class="sd">        different flow executions. Fields starting with &quot;_&quot; are not considered.</span>
<span class="sd">        Also, fields whose values are instances of &quot;StrategyFlow&quot; or &quot;FlowGroup&quot;</span>
<span class="sd">        are not considered, as they would pollute the namespace.</span>

<span class="sd">    All those values form a global namespace. For values with the same, elements</span>
<span class="sd">    or the first group take precedence over the ones in the second group. Values</span>
<span class="sd">    from the second group take precedence over the ones in the last group. This</span>
<span class="sd">    means that</span>

<span class="sd">    This mechanism ensures that any part can have total visibility over the</span>
<span class="sd">    state of the strategy.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">self_ref</span><span class="p">:</span> <span class="n">Any</span><span class="p">,</span> <span class="n">flow_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">root_group_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Creates a flow group.</span>

<span class="sd">        :param self_ref: The reference to the object this flow belongs to. This</span>
<span class="sd">            is usually the the strategy (or the submodule) object.</span>
<span class="sd">        :param flow_name: The name of the flow.</span>
<span class="sd">        :param root_group_name: The name of the root group.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">self_ref</span><span class="p">:</span> <span class="n">Any</span> <span class="o">=</span> <span class="n">self_ref</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">flow_name</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="n">flow_name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">root_flow</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="s1">&#39;StrategyFlow&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">flow_listeners</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Callable</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">namespace_dict</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">kwargs_stack</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_running</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">internal_tracebacks</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="c1"># TODO: leaking &quot;self&quot; in constructor</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">root_group</span><span class="p">:</span> <span class="n">FlowGroup</span> <span class="o">=</span> <span class="n">FlowGroup</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="p">[],</span> <span class="n">root_group_name</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>

<div class="viewcode-block" id="StrategyFlow.append_part_list"><a class="viewcode-back" href="../../../../../../autoapi/avalanche/training/strategies/new_strategy_api/strategy_flow/#avalanche.training.strategies.new_strategy_api.StrategyFlow.append_part_list">[docs]</a>    <span class="k">def</span> <span class="nf">append_part_list</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parts</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">StrategyChild</span><span class="p">],</span>
                         <span class="n">to_group</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">StrategyChildId</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                         <span class="n">after_part</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">StrategyChildId</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                         <span class="n">at_beginning</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Appends a list of parts to a flow group.</span>

<span class="sd">        A flow group is a sequence of parts semantically tied together. For</span>
<span class="sd">        instance &quot;TrainingEpoch&quot;. Parts in a group are executed sequentially.</span>

<span class="sd">        :param parts: A list of parts to append to an existing group.</span>
<span class="sd">        :param to_group: The name of object reference to the group. Defaults to</span>
<span class="sd">            the root group.</span>
<span class="sd">        :param after_part: If not None, the parts list will be appended after</span>
<span class="sd">            the given part/group (described by name or reference).</span>
<span class="sd">        :param at_beginning: If True, the parts will be appended at the</span>
<span class="sd">            beginning of the group. Defaults to False, which means that parts</span>
<span class="sd">            will be appended at the end. Can&#39;t be True at the same time of the</span>
<span class="sd">            &quot;after_part&quot; parameter.</span>
<span class="sd">        :return: None.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">after_part</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">at_beginning</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;after_part and at_beginning can</span><span class="se">\&#39;</span><span class="s1">t be set &#39;</span>
                             <span class="s1">&#39;at the same time&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">to_group</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">to_group</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">root_group</span>
        <span class="n">parts</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">parts</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">root_group</span><span class="o">.</span><span class="n">_append_elements</span><span class="p">(</span><span class="n">to_group</span><span class="p">,</span> <span class="n">after_part</span><span class="p">,</span> <span class="n">parts</span><span class="p">,</span>
                                         <span class="n">at_beginning</span><span class="o">=</span><span class="n">at_beginning</span><span class="p">)</span></div>

<div class="viewcode-block" id="StrategyFlow.append_new_group"><a class="viewcode-back" href="../../../../../../autoapi/avalanche/training/strategies/new_strategy_api/strategy_flow/#avalanche.training.strategies.new_strategy_api.StrategyFlow.append_new_group">[docs]</a>    <span class="k">def</span> <span class="nf">append_new_group</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">group_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
                         <span class="n">parts</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">StrategyChild</span><span class="p">],</span>
                         <span class="n">is_loop</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                         <span class="n">to_group</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">StrategyChildId</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                         <span class="n">after_part</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">StrategyChildId</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                         <span class="n">at_beginning</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Creates a new flow group.</span>

<span class="sd">        :param group_name: The group name.</span>
<span class="sd">        :param parts: A list of initial parts belonging to the group. Can be</span>
<span class="sd">            an empty list.</span>
<span class="sd">        :param is_loop: If True, the group will be flagged as a loop, which</span>
<span class="sd">            means that its parts will be executed in a loop until the last</span>
<span class="sd">            part returns False.</span>
<span class="sd">        :param to_group: Appends the newly created group to the group described</span>
<span class="sd">            (by name or reference) by this parameter. Defaults to None, which</span>
<span class="sd">            means that the root group is used.</span>
<span class="sd">        :param after_part: If not None, the group will be appended after</span>
<span class="sd">            the given part/group (described by name or reference).</span>
<span class="sd">        :param at_beginning: If True, the group will be appended at the</span>
<span class="sd">            beginning of the group. Defaults to False, which means that the</span>
<span class="sd">            group will be appended at the end. Can&#39;t be True at the same time</span>
<span class="sd">            of the &quot;after_part&quot; parameter.</span>
<span class="sd">        :return: The new group</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">new_group</span> <span class="o">=</span> <span class="n">FlowGroup</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">list</span><span class="p">(</span><span class="n">parts</span><span class="p">),</span> <span class="n">group_name</span><span class="p">,</span> <span class="n">is_loop</span><span class="o">=</span><span class="n">is_loop</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">to_group</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">to_group</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">root_group</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">root_group</span><span class="o">.</span><span class="n">_append_elements</span><span class="p">(</span><span class="n">to_group</span><span class="p">,</span> <span class="n">after_part</span><span class="p">,</span> <span class="p">[</span><span class="n">new_group</span><span class="p">],</span>
                                         <span class="n">at_beginning</span><span class="o">=</span><span class="n">at_beginning</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">new_group</span></div>

<div class="viewcode-block" id="StrategyFlow.remove_part"><a class="viewcode-back" href="../../../../../../autoapi/avalanche/training/strategies/new_strategy_api/strategy_flow/#avalanche.training.strategies.new_strategy_api.StrategyFlow.remove_part">[docs]</a>    <span class="k">def</span> <span class="nf">remove_part</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">part_name</span><span class="p">:</span> <span class="n">StrategyChildId</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Removes a part (or group) from the flow.</span>

<span class="sd">        The part will be searched in any flow sub-group.</span>
<span class="sd">        :param part_name: The part name or reference.</span>
<span class="sd">        :return: The removed part.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">root_group</span><span class="o">.</span><span class="n">_remove</span><span class="p">(</span><span class="n">part_name</span><span class="p">)</span></div>

<div class="viewcode-block" id="StrategyFlow.replace_part"><a class="viewcode-back" href="../../../../../../autoapi/avalanche/training/strategies/new_strategy_api/strategy_flow/#avalanche.training.strategies.new_strategy_api.StrategyFlow.replace_part">[docs]</a>    <span class="k">def</span> <span class="nf">replace_part</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">part_name</span><span class="p">:</span> <span class="n">StrategyChildId</span><span class="p">,</span>
                     <span class="n">replacement</span><span class="p">:</span> <span class="n">StrategyChild</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Replaces a part with another.</span>

<span class="sd">        :param part_name: The part (by name or reference) to replace.</span>
<span class="sd">        :param replacement: The replacement.</span>
<span class="sd">        :return: The replaced part.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">root_group</span><span class="o">.</span><span class="n">_replace</span><span class="p">(</span><span class="n">part_name</span><span class="p">,</span> <span class="n">replacement</span><span class="p">)</span></div>

<div class="viewcode-block" id="StrategyFlow.__call__"><a class="viewcode-back" href="../../../../../../autoapi/avalanche/training/strategies/new_strategy_api/strategy_flow/#avalanche.training.strategies.new_strategy_api.StrategyFlow.__call__">[docs]</a>    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Executes this flow .</span>

<span class="sd">        :param kwargs: A dictionary of named parameters that will be passed</span>
<span class="sd">            to the parts of the strategy (see class description).</span>
<span class="sd">        :return: The return value of the last part.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">root_flow</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">root_flow</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_running</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Flow already running&#39;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_running</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">internal_tracebacks</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">namespace_dict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">namespace_dict</span><span class="p">[</span><span class="s1">&#39;flow_listeners&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">flow_listeners</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">namespace_dict</span><span class="p">[</span><span class="s1">&#39;strategy&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">self_ref</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">root_group</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">_</span><span class="p">:</span>
            <span class="n">t</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">tb</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">exc_info</span><span class="p">()</span>
            <span class="c1"># This cleans up the traceback so that decorators and internal</span>
            <span class="c1"># procedures don&#39;t appear!</span>
            <span class="k">raise</span> <span class="n">v</span><span class="o">.</span><span class="n">with_traceback</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_cleanup_traceback</span><span class="p">(</span><span class="n">tb</span><span class="o">.</span><span class="n">tb_next</span><span class="p">))</span>

        <span class="k">finally</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_running</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">namespace_dict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">internal_tracebacks</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">result</span></div>

<div class="viewcode-block" id="StrategyFlow.is_running"><a class="viewcode-back" href="../../../../../../autoapi/avalanche/training/strategies/new_strategy_api/strategy_flow/#avalanche.training.strategies.new_strategy_api.StrategyFlow.is_running">[docs]</a>    <span class="k">def</span> <span class="nf">is_running</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Checks if this flow is running.</span>

<span class="sd">        :return: True if this flow is running, False otherwise.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_submodule_flow</span><span class="p">():</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">root_flow</span><span class="o">.</span><span class="n">is_running</span><span class="p">()</span>
        <span class="c1"># If the submodules field is not found, return []</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_running</span></div>

<div class="viewcode-block" id="StrategyFlow.add_part_change_listener"><a class="viewcode-back" href="../../../../../../autoapi/avalanche/training/strategies/new_strategy_api/strategy_flow/#avalanche.training.strategies.new_strategy_api.StrategyFlow.add_part_change_listener">[docs]</a>    <span class="k">def</span> <span class="nf">add_part_change_listener</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">part_change_listener</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Adds a flow listener.</span>

<span class="sd">        :param part_change_listener: The flow listener to attach. The listener</span>
<span class="sd">            will receive a callback each time a part is executed.</span>
<span class="sd">        :return: None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">root_flow</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">root_flow</span><span class="o">.</span><span class="n">add_part_change_listener</span><span class="p">(</span><span class="n">part_change_listener</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">flow_listeners</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">part_change_listener</span><span class="p">)</span></div>

<div class="viewcode-block" id="StrategyFlow.remove_part_change_listener"><a class="viewcode-back" href="../../../../../../autoapi/avalanche/training/strategies/new_strategy_api/strategy_flow/#avalanche.training.strategies.new_strategy_api.StrategyFlow.remove_part_change_listener">[docs]</a>    <span class="k">def</span> <span class="nf">remove_part_change_listener</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">part_change_listener</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Removes a flow listener.</span>

<span class="sd">        :param part_change_listener: The flow listener to remove.</span>
<span class="sd">        :return: None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">root_flow</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">root_flow</span><span class="o">.</span><span class="n">remove_part_change_listener</span><span class="p">(</span>
                <span class="n">part_change_listener</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">flow_listeners</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">part_change_listener</span><span class="p">)</span></div>

<div class="viewcode-block" id="StrategyFlow.add_strategy_module"><a class="viewcode-back" href="../../../../../../autoapi/avalanche/training/strategies/new_strategy_api/strategy_flow/#avalanche.training.strategies.new_strategy_api.StrategyFlow.add_strategy_module">[docs]</a>    <span class="k">def</span> <span class="nf">add_strategy_module</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">module</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Adds a submodule to the strategy.</span>

<span class="sd">        This will check the submodule for a flow with the same name. If a flow</span>
<span class="sd">        with the same name can&#39;t be found, an exception is raised. The flow</span>
<span class="sd">        found in the submodule is then instrumented to consider this instance as</span>
<span class="sd">        the root flow.</span>

<span class="sd">        :param module: The added submodule.</span>
<span class="sd">        :return: None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">module</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">flow_name</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Can</span><span class="se">\&#39;</span><span class="s1">t find flow with name&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">flow_name</span><span class="p">)</span>
        <span class="nb">getattr</span><span class="p">(</span><span class="n">module</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">flow_name</span><span class="p">)</span><span class="o">.</span><span class="n">set_root_flow</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span></div>

<div class="viewcode-block" id="StrategyFlow.set_root_flow"><a class="viewcode-back" href="../../../../../../autoapi/avalanche/training/strategies/new_strategy_api/strategy_flow/#avalanche.training.strategies.new_strategy_api.StrategyFlow.set_root_flow">[docs]</a>    <span class="k">def</span> <span class="nf">set_root_flow</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">root_flow</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Sets the root flow.</span>

<span class="sd">        When a root flow is set, the current flow will delegate any operation</span>
<span class="sd">        to the root flow. This usually happens in submodules, where the root</span>
<span class="sd">        flow is the strategy one.</span>

<span class="sd">        :param root_flow: The root flow.</span>
<span class="sd">        :return: None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">root_flow</span> <span class="o">=</span> <span class="n">root_flow</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">namespace_dict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span></div>

<div class="viewcode-block" id="StrategyFlow.get_strategy_submodules"><a class="viewcode-back" href="../../../../../../autoapi/avalanche/training/strategies/new_strategy_api/strategy_flow/#avalanche.training.strategies.new_strategy_api.StrategyFlow.get_strategy_submodules">[docs]</a>    <span class="k">def</span> <span class="nf">get_strategy_submodules</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a list of strategy submodules.</span>

<span class="sd">        :return: A list of submodules.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_submodule_flow</span><span class="p">():</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">root_flow</span><span class="o">.</span><span class="n">get_strategy_submodules</span><span class="p">()</span>
        <span class="c1"># If the submodules field is not found, return []</span>
        <span class="k">return</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">self_ref</span><span class="p">,</span> <span class="s1">&#39;submodules&#39;</span><span class="p">,</span> <span class="p">[])</span></div>

<div class="viewcode-block" id="StrategyFlow.is_submodule_flow"><a class="viewcode-back" href="../../../../../../autoapi/avalanche/training/strategies/new_strategy_api/strategy_flow/#avalanche.training.strategies.new_strategy_api.StrategyFlow.is_submodule_flow">[docs]</a>    <span class="k">def</span> <span class="nf">is_submodule_flow</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Checks if this is a flow belonging to a submodule.</span>

<span class="sd">        That is, this returns True if a root flow is set.</span>

<span class="sd">        :return: True if this is a submodule flow, False if it&#39;s the main</span>
<span class="sd">            strategy object flow.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">root_flow</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span></div>

<div class="viewcode-block" id="StrategyFlow.extract_self_namespace"><a class="viewcode-back" href="../../../../../../autoapi/avalanche/training/strategies/new_strategy_api/strategy_flow/#avalanche.training.strategies.new_strategy_api.StrategyFlow.extract_self_namespace">[docs]</a>    <span class="k">def</span> <span class="nf">extract_self_namespace</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Extracts the &quot;self namespace&quot; from the strategy object and any of its</span>
<span class="sd">        submodules. The namespace is then usually searched for when injecting</span>
<span class="sd">        parameter values of the parts.</span>

<span class="sd">        Simply put, the &quot;self namespace&quot; is the collection of class fields</span>
<span class="sd">        belonging to the strategy object and any of its submodules. Fields</span>
<span class="sd">        starting with and underscore &quot;_&quot; will be ignored. For more info, refer</span>
<span class="sd">        to the class documentation.</span>

<span class="sd">        :return: A dictionary containing the self namespace.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_submodule_flow</span><span class="p">():</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">root_flow</span><span class="o">.</span><span class="n">extract_self_namespace</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_extract_self_data</span><span class="p">()</span></div>

<div class="viewcode-block" id="StrategyFlow.get_results_namespace"><a class="viewcode-back" href="../../../../../../autoapi/avalanche/training/strategies/new_strategy_api/strategy_flow/#avalanche.training.strategies.new_strategy_api.StrategyFlow.get_results_namespace">[docs]</a>    <span class="k">def</span> <span class="nf">get_results_namespace</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the &quot;results namespace&quot;. The namespace is then usually searched</span>
<span class="sd">        for when injecting parameter values of the parts.</span>

<span class="sd">        The results namespace is the namespace containing all the results</span>
<span class="sd">        published from any part of the strategy or its submodules. This</span>
<span class="sd">        namespace is cleaned up after each flow execution.</span>

<span class="sd">        For a result to be stored in the &quot;results namespace&quot;, the part must</span>
<span class="sd">        publish it using the &quot;update_results_namespace&quot; method. However, it is</span>
<span class="sd">        recommended to use the &quot;update_namespace&quot; method provided by class</span>
<span class="sd">        :class:`StrategySkeleton`, which is easier to use.</span>

<span class="sd">        :return: A dictionary containing the results namespace.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_submodule_flow</span><span class="p">():</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">root_flow</span><span class="o">.</span><span class="n">get_results_namespace</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">namespace_dict</span></div>

<div class="viewcode-block" id="StrategyFlow.update_results_namespace"><a class="viewcode-back" href="../../../../../../autoapi/avalanche/training/strategies/new_strategy_api/strategy_flow/#avalanche.training.strategies.new_strategy_api.StrategyFlow.update_results_namespace">[docs]</a>    <span class="k">def</span> <span class="nf">update_results_namespace</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">update_dict</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Updates the &quot;results namespace&quot;.</span>

<span class="sd">        For a result to be stored in the &quot;results namespace&quot;, the part must</span>
<span class="sd">        publish it using this method. However, it is recommended to use the</span>
<span class="sd">        &quot;update_namespace&quot; method provided by class :class:`StrategySkeleton`,</span>
<span class="sd">        which is easier to use.</span>

<span class="sd">        :param update_dict: The dictionary or named tuple to merge in the</span>
<span class="sd">            results namespace.</span>
<span class="sd">        :return: None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_submodule_flow</span><span class="p">():</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">root_flow</span><span class="o">.</span><span class="n">update_results_namespace</span><span class="p">(</span><span class="n">update_dict</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_update_namespace_using_return_value</span><span class="p">(</span><span class="n">update_dict</span><span class="p">)</span></div>

<div class="viewcode-block" id="StrategyFlow.get_flattened_kwargs"><a class="viewcode-back" href="../../../../../../autoapi/avalanche/training/strategies/new_strategy_api/strategy_flow/#avalanche.training.strategies.new_strategy_api.StrategyFlow.get_flattened_kwargs">[docs]</a>    <span class="k">def</span> <span class="nf">get_flattened_kwargs</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Gets the &quot;arguments namespace&quot;. This dictionary is then usually</span>
<span class="sd">        searched for when injecting parameter values of the parts.</span>

<span class="sd">        For more info refer to the class documentation.</span>

<span class="sd">        This method looks at the whole call stack on previous strategy parts</span>
<span class="sd">        to gather all previous named parameters. Their values are then flattened</span>
<span class="sd">        (giving priority at values from the most recent call) in the single</span>
<span class="sd">        dictionary returned my this method.</span>

<span class="sd">        Not all parameter from previous part calls are included:</span>

<span class="sd">        -   Only parameters of part calls from the current call *stack* are</span>
<span class="sd">            included, which means that parameters from part calls that already</span>
<span class="sd">            returned are not included.</span>
<span class="sd">        -   Positional only parameters are not included, while &quot;positional</span>
<span class="sd">            or keyword&quot; or &quot;keyword only&quot; parameters are included.</span>
<span class="sd">        -   When the &quot;result namespace&quot; is updated using</span>
<span class="sd">            &quot;update_results_namespace&quot;, any element of the &quot;arguments namespace&quot;</span>
<span class="sd">            with a name included in the update dictionary is eliminated (because</span>
<span class="sd">            part results take precedence over parameters from the call stack).</span>
<span class="sd">            For instance, consider a part that receives as an input a batch,</span>
<span class="sd">            executes a data augmentation procedure and returns it. Let&#39;s call</span>
<span class="sd">            this value &quot;train_batch&quot;. It wouldn&#39;t make sense if, after that part</span>
<span class="sd">            call, the value of &quot;train_batch&quot; pointed to its previous,</span>
<span class="sd">            non-augmented, version. This is why result values take precedence</span>
<span class="sd">            over values from the arguments namespace.</span>

<span class="sd">        :return: The &quot;arguments namespace&quot;. That is, a dictionary of keyword</span>
<span class="sd">            arguments form previous (stack) part calls.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_submodule_flow</span><span class="p">():</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">root_flow</span><span class="o">.</span><span class="n">get_flattened_kwargs</span><span class="p">()</span>

        <span class="n">kwargs_dict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">stack_kwargs_dict</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">kwargs_stack</span><span class="p">:</span>
            <span class="n">_merge_state_data</span><span class="p">(</span><span class="n">kwargs_dict</span><span class="p">,</span> <span class="n">stack_kwargs_dict</span><span class="p">,</span> <span class="n">in_place</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">kwargs_dict</span></div>

<div class="viewcode-block" id="StrategyFlow.push_kwargs"><a class="viewcode-back" href="../../../../../../autoapi/avalanche/training/strategies/new_strategy_api/strategy_flow/#avalanche.training.strategies.new_strategy_api.StrategyFlow.push_kwargs">[docs]</a>    <span class="k">def</span> <span class="nf">push_kwargs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">args_dict</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Pushes keyword arguments.</span>

<span class="sd">        This is usually automatically done when calling a part decorated</span>
<span class="sd">        for the current flow. This updates the &quot;arguments namespace&quot;.</span>

<span class="sd">        :param args_dict: The keyword arguments.</span>
<span class="sd">        :return: None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_submodule_flow</span><span class="p">():</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">root_flow</span><span class="o">.</span><span class="n">push_kwargs</span><span class="p">(</span><span class="n">args_dict</span><span class="p">)</span>

        <span class="n">args_dict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">args_dict</span><span class="p">)</span>
        <span class="n">args_dict</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;self&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">kwargs_stack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">args_dict</span><span class="p">)</span></div>

<div class="viewcode-block" id="StrategyFlow.pop_kwargs"><a class="viewcode-back" href="../../../../../../autoapi/avalanche/training/strategies/new_strategy_api/strategy_flow/#avalanche.training.strategies.new_strategy_api.StrategyFlow.pop_kwargs">[docs]</a>    <span class="k">def</span> <span class="nf">pop_kwargs</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Pops keyword arguments.</span>

<span class="sd">        This is usually automatically done when returning from a part decorated</span>
<span class="sd">        for the current flow. This updates the &quot;arguments namespace&quot;.</span>

<span class="sd">        :return: None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_submodule_flow</span><span class="p">():</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">root_flow</span><span class="o">.</span><span class="n">pop_kwargs</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">kwargs_stack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span></div>

<div class="viewcode-block" id="StrategyFlow.signal_internal_traceback"><a class="viewcode-back" href="../../../../../../autoapi/avalanche/training/strategies/new_strategy_api/strategy_flow/#avalanche.training.strategies.new_strategy_api.StrategyFlow.signal_internal_traceback">[docs]</a>    <span class="k">def</span> <span class="nf">signal_internal_traceback</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tb</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Adds a traceback object to the ignore list.</span>

<span class="sd">        This is usually done to prevent the traceback from showing a huge list</span>
<span class="sd">        of internal decorator calls.</span>

<span class="sd">        :param tb: The traceback object to be ignored.</span>
<span class="sd">        :return: None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_submodule_flow</span><span class="p">():</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">root_flow</span><span class="o">.</span><span class="n">signal_internal_traceback</span><span class="p">(</span><span class="n">tb</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">internal_tracebacks</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">tb</span><span class="p">)</span></div>

<div class="viewcode-block" id="StrategyFlow._update_namespace_using_return_value"><a class="viewcode-back" href="../../../../../../autoapi/avalanche/training/strategies/new_strategy_api/strategy_flow/#avalanche.training.strategies.new_strategy_api.StrategyFlow._update_namespace_using_return_value">[docs]</a>    <span class="k">def</span> <span class="nf">_update_namespace_using_return_value</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">update_dict</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Updates the results namespace.</span>

<span class="sd">        :param update_dict: The dictionary or named tuple to merge in the</span>
<span class="sd">            results namespace.</span>
<span class="sd">        :return: The new results namespace.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_submodule_flow</span><span class="p">():</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">root_flow</span><span class="o">.</span><span class="n">_update_namespace_using_return_value</span><span class="p">(</span>
                <span class="n">update_dict</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">update_dict</span><span class="p">,</span> <span class="nb">dict</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">update_dict</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)</span> <span class="ow">and</span>
                                             <span class="nb">hasattr</span><span class="p">(</span><span class="n">update_dict</span><span class="p">,</span> <span class="s1">&#39;_asdict&#39;</span><span class="p">)):</span>
            <span class="n">update_dict_as_dict</span> <span class="o">=</span> <span class="n">update_dict</span>

            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">update_dict</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
                <span class="n">update_dict_as_dict</span> <span class="o">=</span> <span class="n">update_dict</span><span class="o">.</span><span class="n">_asdict</span><span class="p">()</span>
            <span class="n">update_dict_as_dict</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;self&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">_remove_kwargs_from_stack</span><span class="p">(</span><span class="n">update_dict_as_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>

            <span class="k">return</span> <span class="n">_merge_state_data</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">namespace_dict</span><span class="p">,</span> <span class="n">update_dict</span><span class="p">,</span> <span class="n">in_place</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">namespace_dict</span></div>

<div class="viewcode-block" id="StrategyFlow._cleanup_traceback"><a class="viewcode-back" href="../../../../../../autoapi/avalanche/training/strategies/new_strategy_api/strategy_flow/#avalanche.training.strategies.new_strategy_api.StrategyFlow._cleanup_traceback">[docs]</a>    <span class="k">def</span> <span class="nf">_cleanup_traceback</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tb</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Cleanups the exception traceback.</span>

<span class="sd">        This is done to ensure that internal decorator called are not shown</span>
<span class="sd">        to the user.</span>

<span class="sd">        This method works in-place.</span>

<span class="sd">        :param tb: The traceback.</span>
<span class="sd">        :return: A cleaned up version of the traceback.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">actual_tb</span> <span class="o">=</span> <span class="n">tb</span>
        <span class="k">while</span> <span class="n">actual_tb</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">actual_tb</span><span class="o">.</span><span class="n">tb_next</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">internal_tracebacks</span><span class="p">:</span>
                <span class="n">actual_tb</span><span class="o">.</span><span class="n">tb_next</span> <span class="o">=</span> <span class="n">actual_tb</span><span class="o">.</span><span class="n">tb_next</span><span class="o">.</span><span class="n">tb_next</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">actual_tb</span> <span class="o">=</span> <span class="n">actual_tb</span><span class="o">.</span><span class="n">tb_next</span>
        <span class="k">return</span> <span class="n">tb</span></div>

<div class="viewcode-block" id="StrategyFlow._extract_self_data"><a class="viewcode-back" href="../../../../../../autoapi/avalanche/training/strategies/new_strategy_api/strategy_flow/#avalanche.training.strategies.new_strategy_api.StrategyFlow._extract_self_data">[docs]</a>    <span class="k">def</span> <span class="nf">_extract_self_data</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Extract all fields from the strategy and any submodule.</span>

<span class="sd">        Fields from the main strategy object take precedence over submodules</span>
<span class="sd">        ones.</span>

<span class="sd">        :return: A list of fields from the strategy and its submodules.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">self_namespace</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">self_ref</span><span class="p">,</span> <span class="s1">&#39;submodules&#39;</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">submodule</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">self_ref</span><span class="o">.</span><span class="n">submodules</span><span class="p">:</span>
                <span class="n">flow</span><span class="p">:</span> <span class="s1">&#39;StrategyFlow&#39;</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">submodule</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">flow_name</span><span class="p">)</span>
                <span class="n">self_namespace</span> <span class="o">=</span> <span class="n">_merge_state_data</span><span class="p">(</span>
                    <span class="n">self_namespace</span><span class="p">,</span> <span class="n">flow</span><span class="o">.</span><span class="n">_extract_self_data</span><span class="p">())</span>

        <span class="n">self_dict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">vars</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">self_ref</span><span class="p">))</span>
        <span class="n">private_self_fields</span> <span class="o">=</span> <span class="p">[</span><span class="n">field</span> <span class="k">for</span> <span class="n">field</span> <span class="ow">in</span> <span class="n">self_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
                               <span class="k">if</span> <span class="n">field</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;_&#39;</span><span class="p">)]</span>
        <span class="n">flows_and_groups_fields</span> <span class="o">=</span> <span class="p">[</span><span class="n">field</span> <span class="k">for</span> <span class="n">field</span> <span class="ow">in</span> <span class="n">self_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
                                   <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">self_dict</span><span class="p">[</span><span class="n">field</span><span class="p">],</span> <span class="n">StrategyFlow</span><span class="p">)</span>
                                   <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">self_dict</span><span class="p">[</span><span class="n">field</span><span class="p">],</span> <span class="n">FlowGroup</span><span class="p">)]</span>
        <span class="n">ignored_self_fields</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">private_self_fields</span> <span class="o">+</span> <span class="n">flows_and_groups_fields</span><span class="p">)</span>
        <span class="p">[</span><span class="n">self_dict</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">key</span><span class="p">)</span> <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">ignored_self_fields</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">_merge_state_data</span><span class="p">(</span><span class="n">self_namespace</span><span class="p">,</span> <span class="n">self_dict</span><span class="p">)</span></div>

<div class="viewcode-block" id="StrategyFlow._remove_kwargs_from_stack"><a class="viewcode-back" href="../../../../../../autoapi/avalanche/training/strategies/new_strategy_api/strategy_flow/#avalanche.training.strategies.new_strategy_api.StrategyFlow._remove_kwargs_from_stack">[docs]</a>    <span class="k">def</span> <span class="nf">_remove_kwargs_from_stack</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">arg_names</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">Any</span><span class="p">]):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Removes parameters from the call stack.</span>

<span class="sd">        This is used to remove elements from the &quot;argument namespace&quot;, which</span>
<span class="sd">        has to be done when the &quot;results namespace&quot; is updated.</span>

<span class="sd">        :param arg_names: The names of the parameters.</span>
<span class="sd">        :return: None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">arg_name</span> <span class="ow">in</span> <span class="n">arg_names</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">stack_kwargs_dict</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">kwargs_stack</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">arg_name</span> <span class="ow">in</span> <span class="n">stack_kwargs_dict</span><span class="p">:</span>
                    <span class="k">del</span> <span class="n">stack_kwargs_dict</span><span class="p">[</span><span class="n">arg_name</span><span class="p">]</span></div></div>


<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;StrategyPart&#39;</span><span class="p">,</span> <span class="s1">&#39;StrategyChild&#39;</span><span class="p">,</span> <span class="s1">&#39;StrategyChildId&#39;</span><span class="p">,</span>
           <span class="s1">&#39;make_strategy_part_decorator&#39;</span><span class="p">,</span> <span class="s1">&#39;TrainingFlow&#39;</span><span class="p">,</span> <span class="s1">&#39;TestingFlow&#39;</span><span class="p">,</span>
           <span class="s1">&#39;FlowGroup&#39;</span><span class="p">,</span> <span class="s1">&#39;StrategyFlow&#39;</span><span class="p">]</span>
</pre></div>

           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2020, ContinualAI Research

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>