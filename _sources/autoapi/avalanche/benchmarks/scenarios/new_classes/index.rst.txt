:mod:`avalanche.benchmarks.scenarios.new_classes`
=================================================

.. py:module:: avalanche.benchmarks.scenarios.new_classes


Submodules
----------
.. toctree::
   :titlesonly:
   :maxdepth: 1

   nc_scenario/index.rst
   nc_utils/index.rst


Package Contents
----------------

Classes
~~~~~~~

.. autoapisummary::

   avalanche.benchmarks.scenarios.new_classes.NCScenario
   avalanche.benchmarks.scenarios.new_classes.NCExperience



.. py:class:: NCScenario(train_dataset: AvalancheDataset, test_dataset: AvalancheDataset, n_experiences: int, task_labels: bool, shuffle: bool = True, seed: Optional[int] = None, fixed_class_order: Optional[Sequence[int]] = None, per_experience_classes: Optional[Dict[int, int]] = None, class_ids_from_zero_from_first_exp: bool = False, class_ids_from_zero_in_each_exp: bool = False, reproducibility_data: Optional[Dict[str, Any]] = None)

   Bases: :class:`GenericCLScenario['NCExperience']`

   This class defines a "New Classes" scenario. Once created, an instance
   of this class can be iterated in order to obtain the experience sequence
   under the form of instances of :class:`NCExperience`.

   This class can be used directly. However, we recommend using facilities like
   :func:`avalanche.benchmarks.generators.nc_benchmark`.

   Creates a ``NCGenericScenario`` instance given the training and test
   Datasets and the number of experiences.

   By default, the number of classes will be automatically detected by
   looking at the training Dataset ``targets`` field. Classes will be
   uniformly distributed across ``n_experiences`` unless a
   ``per_experience_classes`` argument is specified.

   The number of classes must be divisible without remainder by the number
   of experiences. This also applies when the ``per_experience_classes``
   argument is not None.

   :param train_dataset: The training dataset. The dataset must be a
       subclass of :class:`AvalancheDataset`. For instance, one can
       use the datasets from the torchvision package like that:
       ``train_dataset=AvalancheDataset(torchvision_dataset)``.
   :param test_dataset: The test dataset. The dataset must be a
       subclass of :class:`AvalancheDataset`. For instance, one can
       use the datasets from the torchvision package like that:
       ``test_dataset=AvalancheDataset(torchvision_dataset)``.
   :param n_experiences: The number of experiences.
   :param task_labels: If True, each experience will have an ascending task
       label. If False, the task label will be 0 for all the experiences.
   :param shuffle: If True, the class order will be shuffled. Defaults to
       True.
   :param seed: If shuffle is True and seed is not None, the class order
       will be shuffled according to the seed. When None, the current
       PyTorch random number generator state will be used.
       Defaults to None.
   :param fixed_class_order: If not None, the class order to use (overrides
       the shuffle argument). Very useful for enhancing
       reproducibility. Defaults to None.
   :param per_experience_classes: Is not None, a dictionary whose keys are
       (0-indexed) experience IDs and their values are the number of
       classes to include in the respective experiences. The dictionary
       doesn't have to contain a key for each experience! All the remaining
       experiences will contain an equal amount of the remaining classes.
       The remaining number of classes must be divisible without remainder
       by the remaining number of experiences. For instance,
       if you want to include 50 classes in the first experience
       while equally distributing remaining classes across remaining
       experiences, just pass the "{0: 50}" dictionary as the
       per_experience_classes parameter. Defaults to None.
   :param class_ids_from_zero_from_first_exp: If True, original class IDs
       will be remapped so that they will appear as having an ascending
       order. For instance, if the resulting class order after shuffling
       (or defined by fixed_class_order) is [23, 34, 11, 7, 6, ...] and
       class_ids_from_zero_from_first_exp is True, then all the patterns
       belonging to class 23 will appear as belonging to class "0",
       class "34" will be mapped to "1", class "11" to "2" and so on.
       This is very useful when drawing confusion matrices and when dealing
       with algorithms with dynamic head expansion. Defaults to False.
       Mutually exclusive with the ``class_ids_from_zero_in_each_exp``
       parameter.
   :param class_ids_from_zero_in_each_exp: If True, original class IDs
       will be mapped to range [0, n_classes_in_exp) for each experience.
       Defaults to False. Mutually exclusive with the
       ``class_ids_from_zero_from_first_exp parameter``.
   :param reproducibility_data: If not None, overrides all the other
       scenario definition options. This is usually a dictionary containing
       data used to reproduce a specific experiment. One can use the
       ``get_reproducibility_data`` method to get (and even distribute)
       the experiment setup so that it can be loaded by passing it as this
       parameter. In this way one can be sure that the same specific
       experimental setup is being used (for reproducibility purposes).
       Beware that, in order to reproduce an experiment, the same train and
       test datasets must be used. Defaults to None.

   .. attribute:: classes_order
      :annotation: :List[int] = []

      Stores the class order (remapped class IDs). 


   .. attribute:: classes_order_original_ids
      :annotation: :List[int]

      Stores the class order (original class IDs) 


   .. attribute:: class_mapping
      :annotation: :List[int] = []

      class_mapping stores the class mapping so that 
      `mapped_class_id = class_mapping[original_class_id]`. 

      If the scenario is created with an amount of classes which is less than
      the amount of all classes in the dataset, then class_mapping will 
      contain some -1 values corresponding to ignored classes. This can
      happen when passing a fixed class order to the constructor.


   .. attribute:: n_classes_per_exp
      :annotation: :List[int] = []

      A list that, for each experience (identified by its index/ID),
      stores the number of classes assigned to that experience. 


   .. attribute:: original_classes_in_exp
      :annotation: :List[Set[int]] = []

      A list that, for each experience (identified by its index/ID), stores a 
      set of the original IDs of classes assigned to that experience. 
      This field applies to both train and test streams.


   .. attribute:: class_ids_from_zero_from_first_exp
      :annotation: :bool

      If True the class IDs have been remapped to start from zero. 


   .. attribute:: class_ids_from_zero_in_each_exp
      :annotation: :bool

      If True the class IDs have been remapped to start from zero in 
      each experience 


   .. attribute:: n_classes
      :annotation: :int

      The number of classes 


   .. attribute:: train_exps_patterns_assignment
      

      A list containing which training instances are assigned to each
      experience in the train stream. Instances are identified by their id 
      w.r.t. the dataset found in the original_train_dataset field. 


   .. attribute:: test_exps_patterns_assignment
      

      A list containing which test instances are assigned to each
      experience in the test stream. Instances are identified by their id 
      w.r.t. the dataset found in the original_test_dataset field. 


   .. method:: get_reproducibility_data(self)

      Gets the data needed to reproduce this experiment.

      This data can be stored using the pickle module or some other mechanism.
      It can then be loaded by passing it as the ``reproducibility_data``
      parameter in the constructor.

      Child classes should create their own reproducibility dictionary.
      This means that the implementation found in :class:`GenericCLScenario`
      will return an empty dictionary, which is meaningless.

      In order to obtain the same benchmark instance, the reproducibility
      data must be passed to the constructor along with the exact same
      input datasets.

      :return: A dictionary containing the data needed to reproduce the
          experiment.


   .. method:: classes_in_exp_range(self, exp_start: int, exp_end: Optional[int] = None) -> List[int]

      Gets a list of classes contained in the given experiences. The
      experiences are defined by range. This means that only the classes in
      range [exp_start, exp_end) will be included.

      :param exp_start: The starting experience ID.
      :param exp_end: The final experience ID. Can be None, which means that
          all the remaining experiences will be taken.

      :returns: The classes contained in the required experience range.



.. py:class:: NCExperience(origin_stream: GenericScenarioStream['NCExperience', NCScenario], current_experience: int)

   Bases: :class:`GenericExperience[NCScenario, GenericScenarioStream['NCExperience', NCScenario]]`

   Defines a "New Classes" experience. It defines fields to obtain the current
   dataset and the associated task label. It also keeps a reference to the
   stream from which this experience was taken.

   Creates a ``NCExperience`` instance given the stream from this
   experience was taken and and the current experience ID.

   :param origin_stream: The stream from which this experience was
       obtained.
   :param current_experience: The current experience ID, as an integer.


